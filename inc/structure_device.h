#ifndef STRUCTURE_DEVICE_H
#define STRUCTURE_DEVICE_H

//Name: all the structures used in GGMCS:
//Editor:Bo Ma
//Date:2016.12.29


//CUDA RunTime API
#include <cuda_runtime.h>







//#ifdef __CUDACC__
//#ifdef __CUDA_ARCH__

    __constant__ const float gpu_pi = 3.14159265358979323846;
    __constant__ const float gpu_twopi = 2*gpu_pi;
    __constant__ const float gpu_halfpi = gpu_pi/2;
    __constant__ const float gpu_speed_of_light = 3.33564095198e-03f;
//#endif


#ifndef GPUPHANTOM
#define GPUPHANTOM
struct GPUPhantom {
  unsigned short int *data;//phantom image which is generated by the Attenuation image(320*320*153 with coil). The value is the index of each material. The material name which corresponds to the index is saved in the structure of GPUPhantomMaterials;
  unsigned int mem_data;//the memory size of the phantom:320*320*153*sizeof(short)
  float3 size_in_mm;//size of the phantom in mm 320*1.25,320*1.25,153*1.25;
  int3 size_in_vox;//phantom matrix size:320*320*153;
  float3 voxel_size;//1.25*1.25*1.25;
  int nb_voxel_volume;//total voxel number:320*320*153;
  int nb_voxel_slice;//pixel number per slice:320*320;
};
#endif

#ifndef GPUPHANTOMMATERIALS
#define GPUPHANTOMMATERIALS
// GPU Structure of Arrays for phantom materials
struct GPUPhantomMaterials {
    unsigned int nb_materials;//how many materials in the phantom.
    unsigned int nb_elements_total;         // k

    unsigned short int *nb_elements;        // n
    unsigned short int *index;              // n
    unsigned short int *mixture;            // k
    float *atom_num_dens;                   // k
};
#endif

#ifndef GPUPHANTOMACTIVITIES
#define GPUPHANTOMACTIVITIES
// GPU SoA for phantom activities
struct GPUPhantomActivities{
    unsigned int nb_activities;//number of voxels whose activity is not zero
    float tot_activity;//the total of the activity;
    unsigned int *act_index;//the index of the voxel whose activity is not zero
    float *act_cdf;//the activity of the voxels whose activity is not zero(in format of cumulative frequency function
    float3 size_in_mm;//the size of the whole source in milimeter
  	int3 size_in_vox;//the total voxel number of the source
    float3 voxel_size;//the size of each voxel in mm
};
#endif


#ifndef GPUSCANNER
#define GPUSCANNER


// GPU SoA for scanner geometry
struct GPUScanner{
    float cyl_radius;//187.96
    float cyl_halfheight;//96.25f
    float block_pitch;//32.5f
    float cta_pitch;//crystal size:2.5f
    float cax_pitch;//crystal size:2.5f
    unsigned short int ncass;//32
    unsigned short int nblock;//6 per cassette
    unsigned short int ncry_ta;//12 per block
    unsigned short int ncry_ax;//12 per block
    unsigned short int blocksize;//ncry_ta*ncry_ax=12*12;
    float3 halfsize;// real blocksize only with crystal:x:12*2.5=30;y:20mm;Z:12*2.5
    float3* pos;//position for each block in mm. matrix size:32*6=192
    float3* v0;// I don't know yet' matrix size:32=the cassette
    float3* v1;//same to v0
    float3* v2;//same to v0

    GPUPhantomMaterials mat; //phantom materials
};
#endif

#ifndef CPUSTACKPARTICLE
#define CPUSTACKPARTICLE
// Stack of particles, format data is defined as SoA
struct GPUParticleStack {
	float* E;
	float* dx;
	float* dy;
	float* dz;
	float* px;
	float* py;
	float* pz;
	float* tof;
	unsigned int* seed;
	unsigned char* endsimu;
	unsigned char* active;
	unsigned long* table_x_brent;
	short int* crystalID;
	short int* nCompton; //Compton times in the phantom
	short int* nCompton_crystal; //compton times in crystal
	short int* nPhotoelectric_crystal; //photoelectric in crystal
	float* Edeposit;
	unsigned int size;
};
//
#endif


















#endif




